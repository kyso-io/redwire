// Generated by CoffeeScript 1.8.0
var TcpProxy, net, parse_url, tls,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __slice = [].slice;

net = require('net');

tls = require('tls');

parse_url = require('url').parse;

module.exports = TcpProxy = (function() {
  function TcpProxy(options, bindings) {
    this.close = __bind(this.close, this);
    this.tlsError = __bind(this.tlsError, this);
    this._tlsError = __bind(this._tlsError, this);
    this.tcpError = __bind(this.tcpError, this);
    this._tcpError = __bind(this._tcpError, this);
    this.proxyTls = __bind(this.proxyTls, this);
    this.proxyTcp = __bind(this.proxyTcp, this);
    this._startTls = __bind(this._startTls, this);
    this._startTcp = __bind(this._startTcp, this);
    var _ref, _ref1;
    this._options = options;
    this._bindings = bindings;
    if (this._options.tcp) {
      this._startTcp();
    }
    if (this._options.tls) {
      this._startTls();
    }
    if (((_ref = this._options.tcp) != null ? _ref.dest : void 0) != null) {
      setTimeout((function(_this) {
        return function() {
          return _this._bindings().tcp(_this._options.tcp.dest);
        };
      })(this), 1);
    }
    if (((_ref1 = this._options.tls) != null ? _ref1.dest : void 0) != null) {
      setTimeout((function(_this) {
        return function() {
          return _this._bindings().tls(_this._options.tls.dest);
        };
      })(this), 1);
    }
  }

  TcpProxy.prototype._startTcp = function() {
    this._tcpServer = net.createServer((function(_this) {
      return function(socket) {
        socket.on('error', function() {
          var args, _ref;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return (_ref = _this._tcpServer).emit.apply(_ref, ['error'].concat(__slice.call(args)));
        });
        return _this._bindings()._tcp.exec({}, socket, _this.tcpError('No rules caught tcp connection'));
      };
    })(this));
    this._tcpServer.on('error', this._options.log.error);
    this._tcpServer.listen(this._options.tcp.port);
    return this._options.log.notice("tcp server listening on port " + this._options.tcp.port);
  };

  TcpProxy.prototype._startTls = function() {
    this._tlsServer = tls.createServer(this.certificates.getTlsOptions(this._options.tls), (function(_this) {
      return function(socket) {
        socket.on('error', function() {
          var args, _ref;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return (_ref = _this._tlsServer).emit.apply(_ref, ['error'].concat(__slice.call(args)));
        });
        return _this._bindings()._tls.exec({}, socket, _this.tlsError('No rules caught tls connection'));
      };
    })(this));
    this._tlsServer.on('error', this._options.log.error);
    this._tlsServer.listen(this._options.tls.port);
    return this._options.log.notice("tls server listening on port " + this._options.tls.port);
  };

  TcpProxy.prototype.proxyTcp = function(target) {
    return (function(_this) {
      return function(req, socket, next) {
        var proxySock, t, url;
        t = target;
        if (t == null) {
          t = req.target;
        }
        if ((t != null) && typeof t === 'string' && t.indexOf('tcp://')) {
          t = "tcp://" + t;
        }
        if (t == null) {
          return _this._tcpError(req, socket, 'No server to proxy to');
        }
        url = parse_url(t);
        url = {
          host: url.hostname,
          port: url.port
        };
        proxySock = net.connect(url).on('error', function() {
          var args, _ref;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return (_ref = _this._tcpServer).emit.apply(_ref, ['error'].concat(__slice.call(args)));
        }).on('end', function() {
          return socket.end();
        });
        proxySock.pipe(socket).pipe(proxySock);
        return socket.on('end', function() {
          return proxySock.end();
        });
      };
    })(this);
  };

  TcpProxy.prototype.proxyTls = function(options, target) {
    return (function(_this) {
      return function(req, socket, next) {
        var proxySock, t, url;
        if (target == null) {
          target = options;
          options = null;
        }
        t = target;
        if (t == null) {
          t = req.target;
        }
        if ((t != null) && t.indexOf('tls://')) {
          t = "tls://" + t;
        }
        if (t == null) {
          return _this._tlsError(req, socket, 'No server to proxy to');
        }
        if (options == null) {
          options = req;
        }
        url = parse_url(t);
        url = {
          host: url.hostname,
          port: url.port
        };
        proxySock = tls.connect(options, url).on('error', function() {
          var args, _ref;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return (_ref = _this._tlsServer).emit.apply(_ref, ['error'].concat(__slice.call(args)));
        });
        return proxySock.pipe(socket).pipe(proxySock);
      };
    })(this);
  };

  TcpProxy.prototype._tcpError = function(req, socket, message) {
    this._options.log.error(message);
    return socket.destroy();
  };

  TcpProxy.prototype.tcpError = function(message) {
    return (function(_this) {
      return function(req, socket, next) {
        return _this._tcpError(req, socket, message);
      };
    })(this);
  };

  TcpProxy.prototype._tlsError = function(req, socket, message) {
    this._options.log.error(message);
    return socket.destroy();
  };

  TcpProxy.prototype.tlsError = function(message) {
    return (function(_this) {
      return function(req, socket, next) {
        return _this._tlsError(req, socket, message);
      };
    })(this);
  };

  TcpProxy.prototype.close = function(cb) {
    if (this._tcpServer != null) {
      this._tcpServer.close();
    }
    if (this._tlsServer != null) {
      this._tlsServer.close();
    }
    if (cb != null) {
      return cb();
    }
  };

  return TcpProxy;

})();
